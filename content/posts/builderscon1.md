---
title: "Builderscon1"
date: 2018-09-07T12:05:33+09:00
draft: true
---

# BuildersConメモ

## [Envoy internals deep dive](https://builderscon.io/tokyo/2018/session/838113b5-ea55-40ae-8ef5-eb461e7b97a2)

まず同時通訳がすごかった。ほぼ原文の漏れなくリアルタイムでガンガン通訳する。

Envoyの説明

モノリシックなデザインからMicroservicesに移行したけど、
マイクロサービスも次のような問題がある。

- どこで問題が発生してるのかわかりづらい
- 一貫したロギングが難しい
- 多言語が採用されている場合、全ての言語に採用ライブラリが提供される保証はない。
  - ライブラリを採用言語にポーティングすることもあるが、リソースを圧迫する。

Client -> Thread : お客さん -> 料理人  

Clinet -> EventLoop -> Thread : お客さん -> ウェイター -> 料理人

### 用語

- gRPC
- circuit break

## [開発現場で役立たせるための設計原則とパターン](https://builderscon.io/tokyo/2018/session/34027adb-d0a4-4dd7-9a44-8297a087dc44)

設計抽象的な話になりがち  
責務ってこのxxxなクラスはxxxな責務です！と言われたらまぁそうと言わざるを得ない

設計。複数の分割構造の選択肢から適切な構造を選び出すアクティビティ。デザインパターンは分割カタログ。

SOLIDの説明

設計原則を用いるとセルフチェックができる。  

ボタンが押された時（ボタン）  
　レンジをチンする（レンジ）  
　掃除機をオンにする(掃除機)  

オブザーバーパターン  
レンジをボタンに登録  
　ボタンが押されたらレンジに通知が届く。  

Single Responsibility

責務は仕様変更が発生するまでわからない、
設計対象となる問題をよく観察して、変更理由を知ることが大事。どこがかわりやすいポイントなのかしることが大事。

新しい学びは少なかったが、新人に研修をするときの良いサンプルになった気がする。

マルチパラダイムパターン

YAGNIはわかるけど、気付いた時にはもう変更できない組織だと辛い。

## [事前知識なしで理解する、静的検査のいろは](https://builderscon.io/builderscon/tokyo/2018/session/0a3ee8c0-44ce-4cb9-9199-05b350887d79)

[Slide](https://speakerdeck.com/orgachem/introduction-about-static-analysis-without-previous-knowledge)

## [JavaCardの世界](https://builderscon.io/tokyo/2018/session/c9420e29-489d-4abe-b8d7-96d1e4d61b47)

JavaCard

あの金色のチップ

- クレカ
- SIM

SmartCard ISO7816

- Intelligent Smart Card <- JavaCard
- MemoryCard <- 単なるストレージ

CardはAPDU(Application Data Unit)というプロトコルで外界と通信する。

UICC  
Inteligent Smart Cardの一種　　
ある程度の演算ができる  

1M〜5M Hz
CPU
ROM
EPROM(書き換えできる)
RAM
普通にCPU

Core O.S(Docker関係ない)
ファイルシステムもある。普通にファイルを取り扱える。

JCRE(Java Card Runtime Edition)
機能はかなり制限されており、下記は使えない。
動的クラスローディング
ファイナライズ
スレッド
大きなプリミティブ型(char, float)
etc...

GCはカードの実装次第

基本インスタンス変数はEPROMに書き込まれる。
電源が切れてもインスタンス変数のデータは残る。

RAMはめっちゃ小さい(8byte)
本当に一時的なデータのみ入れる

JVMは一生動き続ける
電源供給がない場合は無限のクロックサイクル。完全に一時停止しているような状況になっている。

Java CardはAppletを同時に実行はできないが、同時に起動させておくことはできる。複数のアプレットを選択して起動さ焦る。

EPROMの寿命は100,000writes

開発サイクル

普通のJavaを書いてConverterかける。

How to write  a Java Card applet

Javaカードはどこでかえるのか

Amazon/Aliexple  

どんなアプリが動いているのか  
アイデンティフィケーションの処理  
SIM認証系  
通信暗号化

Q JavaCardの未来は？  
A クレカ/携帯が死滅しなければ

Q JavaCardのコードを検索したいときは？  
A javacard.frameworkはぜったい使われている

Q SmartCardはなぜJavaなのか  
A SmartCard登場当初はC, Lisp実装もあったらしいが自然淘汰の結果JavaCardがのこった。セキュリティレベルが高かったから？

Q EPROM破壊を防ぐための独自テクはあるか？  
A 洗練されたテクはない。基本耐久テスト。壊れるやつはテストですぐ壊れる。

## [lld − 開発ツールの主要コンポーネントの1つをスクラッチから作成した話](https://builderscon.io/tokyo/2018/session/a5d70539-6cb2-4d9c-a472-3e48f2eb3183)

リンカの基本概念

catして全体を作って、
断片化している時には決定できなかったメモリ配列を決定する。他のファイルで定義されている関数。

リロケーション
リンカの仕事

Chrome
のリロケーション13000000
1μ秒多く費やすと合計で13秒遅くなる

作りはじめた当初
全く動かない

徐々に動かす
エラーをはかない実行ファイル
単一ファイル
複数ファイル
etc...
HelloWorldを動かすまで数ヶ月

ターゲットの実行環境毎に色々異なる。
概念は同じだが

実行環境に依存しない中間コードに直そうとすると無理がでた。

書き直し決意
文句言われたけど、文句言ってる人は書いてるわけじゃないので書き直し開始

書き直したらめっちゃ早くなる

書き直した結果、賛同する新しい仲間が増えてくる

リデザインのポイント

- 難しくしすぎない
- 自然と早くなるようなものにする
- データ構造が重要
- こうなったら早いというデータ構造に自然と作っていく。

マルチターゲット

中間表現を導入する
ダメ

全ターゲットでデザインを共有するが、コードは共有しない。
ターゲット毎に似たようなコードを書かなくてはいけないが、似ているだけで厳密には違う。これを共通化すると大変だった。

早くてシンプルなコードを書くために

- データ構造
- 2回書く
- 最適化する箇所を最小化する

- Q 2度書き直しするといいということだけど、前の実装に引っ張られる何か心がけはあるか。
- A 答えになっていないが、問題点を試行錯誤的に潰しているだけ

- Q 次の目標は
- A Linuxディストリビューション全体が10秒くらいでビルドできたらいいですね。

慣習に従ったReasonがない実装は積極的に拒否する。そんなパッチが来ても入れない。慣習が間違っていることは多々ある。全てに理由と理屈を求める。